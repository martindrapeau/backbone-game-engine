<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Backbone Game Engine</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href="favicon.ico" rel="shortcut icon" type="image/x-icon" />
    <link href="apple_touch_icon.png" rel="apple-touch-icon" />
    
    <script src="docs-3rd/jquery.min.js" type="text/javascript"></script>
    <script src="docs-3rd/bootstrap.min.js" type="text/javascript"></script>
    <link href="docs-3rd/bootstrap.min.css" rel="stylesheet" type="text/css" charset="utf-8">
    
    <style>
      header.navbar-inverse {border-radius: 0;}
      footer.navbar-default {border-radius: 0; margin-bottom: 0;}
    </style>
  </head>
  <body>
    <header class="navbar navbar-inverse">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="#">Backbone Game Engine</a>
      </div>
      <div class="collapse navbar-collapse" id="navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="#introduction">Introduction</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li><a href="#documentation-Backbone">Backbone</a></li>
              <li><a href="#documentation-Structure">Structure</a></li>
              <li><a href="#documentation-Engine">Backbone.Engine</a></li>
              <li><a href="#documentation-SpriteSheet">Backbone.SpriteSheet</a></li>
              <li><a href="#documentation-Sprite">Backbone.Sprite</a></li>
              <li><a href="#documentation-Input">Backbone.Input</a></li>
              <li class="divider"></li>
              <li><a href="#documentation-World">Backbone.World</a></li>
              <li><a href="#documentation-WorldEditor">Backbone.WorldEditor</a></li>
              <li><a href="#documentation-Hero">Backbone.Hero</a></li>
              <li><a href="#documentation-Camera">Backbone.Camera</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </header>
    <div class="container">

      <div class="row">
        <div class="col-md-12">
          <h1 id="introduction">Introduction</h1>
          <p>
            An elementary HTML5 Game Engine built on Backbone. Examples:
          </p>
          <ul>
            <li>Basice: <a href="mario/index.html" target="_blank">Mario in an empty world</a></li>       
            <li>Advanced: <a href="super-mario-bros/index.html" target="_blank">Super Mario Bros, level 1-1</a></li>     
          </ul>

          <h3>Features:</h3>
          <ul>
            <li><strong>Built on Backbone</strong>. Events, models, collections, inheritance and RESTful persistence. Why reinvent the wheel?</li>
            <li><strong>HTML5 canvas only</strong>. No jQuery, as little DOM manipulations as possible.</li>
            <li><strong>No compilation</strong>. You don't need to install node, grunt or whatever else. Just code and press F5 to run.</li>
            <li><strong>No server required</strong>. Fork this repo and your Github site is up and going. Create your own game and point your friends to it. Rebase to pull in latest engine updates.</li>
            <li><strong>Built for mobile</strong>. Conceived to run on tablets. Share your URL with Mom so she can add it to the home screen of her iPad.</li>
            <li><strong>Take if offline</strong>. With HTML5 Application Cache, your game runs offline. Perfect for taking it on the road or a fishing trip.</li>
            <li><strong>Save state</strong>. With HTML5 Local Storage, save where you are.</li>
            <li><strong>Level editor</strong>. Conceived for tile-based games, comes with a level editor. Place your tiles and characters, then hit play to try it out. Hit save to save your level.</li>
          </ul>

          <h3>Dependencies</h3>
          <ul>
            <li><a href="http://underscorejs.org/" target="_blank">Underscore</a> </li>
            <li><a href="http://backbonejs.org/" target="_blank">Backbone</a> </li>
            <li><a href="https://github.com/inkling/backbone.native/" target="_blank">backbone.native</a>. To drop jQuery.</li>
            <li><a href="http://eightmedia.github.io/hammer.js/" target="_blank">hammer.js</a>. To handle touch events.</li>
          </ul>
          <p>All included in the <a href="/backbone-game-engine/tree/gh-pages/3rd">3rd folder</a>.  That and nothing else.</p>

          <h3>Why Backbone?</h3>
          <p>
            Backbone implements <a href="http://backbonejs.org/#Events" target="_blank">events</a>, <a href="http://backbonejs.org/#Model" target="_blank">models</a>, <a href="http://backbonejs.org/#Collection" target="_blank">collections</a>, <a href="http://backbonejs.org/#Model-extend" target="_blank">inheritance</a> and <a href="http://backbonejs.org/#Sync" target="_blank">persistence</a>. Models implement getters and setters for object attributes. Models and Collections have an <code>extend</code> function to easily do inheritance. They implement methods for persistence (RESTful JSON by default). They can also trigger events and bind to them. Everything you need to build a great extensible game engine. Plus, Backbone is now widely used and provides these features in a standard fashion with a huge community to support them. I hope this project can make game programming accessible to developers already familiar with Backbone.
          </p>

          <h3 id="getting-started">Getting Started</h3>
          <p>
            Backbone Game Engine was built to get you going fast. <a href="https://github.com/martindrapeau/backbone-game-engine">Fork this repository</a>, and your own Github page will be ready in minutes. You can then create your own games by simply creating a new directory, and putting files in it. Here is the recommended file structure:
          </p>
          <pre>
3rd/
src/
...
super-mario-bros/
my-game/
        index.html
        main.js
        sprites.js
        sprite-sheet.png
</pre>
          <p>
            <code>index.html</code> is the HTML document which loads your assets, and defines your canvas. <code>sprite.js</code> contains your sprite class definitions, and <code>sprite-sheet.png</code> your graphics. Finally, <code>main.js</code> is where you instantiate the game engine and sprites. It must get loaded last.
          </p>
          <br/>
        </div>
      </div>

      <!-- Documentation -->
      <div class="row">
        <div class="col-md-12">
          <h1 id="documentation">Documentation</h1>

        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-Backbone">Backbone</h3>
          <p>
            The engine is based on Backbone so it is essential to understand its core structure: a <a hred="http://backbonejs.org/#Model" target="_blank">Backbone.Model</a>. A model has hash of <code>attributes</code> that are changed via getter and setter methods <code>get</code> and <code>set</code>. These attributes should only contain state information as it is those attributes which get saved and restored. A model is a Javascript object. Hence behaviour can be stored as properties and methods directly on the object. For example, a sprite points to a sprite sheet. The sprite sheet id is stored as an attribute, but the pointer to the sprite sheet model is stored in a property.
          </p>
          <p>
            In fact, a model stores its attributes in the object property <code>attributes</code>. Methods <code>get</code>, <code>set</code> and <code>toJSON</code> operate on that property. Just remember that state date like sprite coordinates, velocity, etc go in there. However references to other objects do not.
            <div class="alert alert-info">
              Note on nomenclature: I use the word <strong>attribute</strong> to define state data (get and set stored in obejct property attributes) while we use the word <strong>property</strong> to define behavioural data stored directly on the object.
            </div>
          </p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-Structure">Structure</h3>
          <p>
            Games and examples are located in their own directory with at least two files <code>index.html</code> and <code>main.js</code>. The HTML file can reference Javascript files, and images using relative paths.
          </p>

          <h4 id="documentation-HTML">index.html</h4>
          <p>
            The HTML document (usually named <code>index.html</code> in its own folder) declares the assets to be loaded and the <code>canvas</code> element. Javascript assets are declared in the <code>HEAD</code> element. Images are loaded via <code>IMG</code> elements. They must be hidden with inline CSS. Everything is bootstrap-loaded as declared in the HTML file. There is no asynchronous loading.
          </p>
          <p>
            Here is an example HTML file taken from the example <a href="mario/index.html" target="_blank">Mario</a>.
          </p>
          <pre>
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Mario - Backbone Game Engine&lt;/title&gt;
        &lt;meta charset="utf-8"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
        &lt;link href="../favicon.ico" rel="shortcut icon" type="image/x-icon" /&gt;
        &lt;link href="../apple_touch_icon.png" rel="apple-touch-icon" /&gt;

        &lt;meta name="viewport" content="width=960, user-scalable=no"/&gt;
        &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;

        &lt;script src="../3rd/underscore.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../3rd/backbone.native.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../3rd/backbone.js" type="text/javascript"&gt;&lt;/script&gt;

        &lt;script src="../src/shapes.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../src/core.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../src/input.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../src/hero.js" type="text/javascript"&gt;&lt;/script&gt;
        &lt;script src="../src/world.js" type="text/javascript"&gt;&lt;/script&gt;

        &lt;script src="main.js" type="text/javascript"&gt;&lt;/script&gt;

        &lt;style&gt;
            body {
                margin: 0;
                background-color: #000;
            }
            canvas {
                position: fixed;
                top: 0;
                left: 0;
            }
        &lt;/style&gt;

    &lt;/head&gt;

    &lt;body&gt;
        &lt;img id="mario" src="../super-mario-bros/super-mario-2x.png" style="display:none;" /&gt;
        &lt;canvas id="foreground" width="960" height="700"&gt;
            Your browser does not support canvas element.
        &lt;/canvas&gt;
        &lt;canvas id="background" width="960" height="544" style="display:none;"&gt;
            Your browser does not support canvas element.
        &lt;/canvas&gt;
    &lt;/body&gt;

&lt;/html&gt;
</pre>
          <p>
            Some important notes:
          </p>
          <ul>
            <li>HTML meta tags <code>viewport</code> and <code>apple-mobile-web-app-capable</code> ensure the canvas is properly sized on iPads and other mobile devices.  The width of specified there should be the same as the canvas elements.</li>
            <li>Elements must all have ids since we use the native <code>getElementById</code> Javascript function to retrieve the <code>Canvas</code> and <code>Image</code> objects from their respective DOM elements.</li>
            <li>Canvas ided <code>background</code> is used as a secondary buffer in <a href="#documentaiton-World">Backbone.World</a> (to draw the background). It must remain hidden. Its height is less than that of the <code>foreground</code> canvas since the bottom real-estate is taken by either a <a href="#documentation-Input">Backbone.Input</a> or <a href="#documentation-WorldEditor">Backbone.WorldEditor</a> model.</li>
          </ul>

          <h4 id="documentation-main">main.js</h4>
          <p>
            File <code>main.js</code> is where you declare and initialize your objects. It is recommended that you wrap that code in a function which gets executed once the document is loaded (document ready event). For convenience, <a href="https://github.com/inkling/backbone.native/" target="_blank">Backbone.native</a> was extended with that event with the jQuery syntax you are familiar with: <code>$(document).ready(function() {});</code>. 
          </p>
          <p>
            Other files use a simple closure instead since they contain class definitions mainly. However in <code>main.js</code> is where <code>Canvas</code> and <code>Image</code> objects are retrieved from the DOM elements. Remember that assets are loaded synchronously.
          </p>
          <p>
            Here is a sample <code>main.js</code> file, taken from the <a href="mario/index.html" target="_blank">Mario</a> example.
          </p>
          <pre>
$(document).ready(function() {

  // Mario alone in an empty world. Control him with the touchpad.

  Backbone.Mario = Backbone.Hero.extend({
    defaults: _.extend({}, Backbone.Hero.prototype.defaults, {
      name: "mario",
      spriteSheet: "mario"
    })
  });

  var canvas = document.getElementById("foreground");

  var spriteSheets = new Backbone.SpriteSheetCollection([{
    id: "mario",
    img: "#mario",
    tileWidth: 32,
    tileHeight: 64,
    tileColumns: 21,
    tileRows: 6
  }]).attachToSpriteClasses();

  var debugPanel = new Backbone.DebugPanel();

  var input = new Backbone.Input({
    drawTouchpad: true,
    drawPause: true
  });

  var mario = new Backbone.Mario({
    x: 400, y: 400
  }, {
    input: input
  });

  var world = new Backbone.World({
    width: 30, height: 18,
    tileWidth: 32, tileHeight: 32,
    backgroundColor: "rgba(66, 66, 255, 1)"
  });
  world.add(mario);

  var engine = new Backbone.Engine([
    world,
    input,
    debugPanel
  ], {
    canvas: canvas,
    debugPanel: this.debugPanel,
    input: input
  });

  // Expose things as globals - easier to debug
  _.extend(window, {
    canvas: canvas,
    engine: engine
  });

});
</pre>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-Engine">Backbone.Engine</h3>
          <pre>new Backbone.Engine([models], [options])</pre>
          <h4>Options</h4>
          <ul>
            <li><code>canvas</code>: The canvas to draw upon. Drawing is on its 2d context.</li>
            <li><code>input</code>: Optional. The user control input instance. If passed and the pause button is enabled, will stop/start then engine when pressed.</li>
            <li><code>debugPanel</code>: Optional. If passed <code>fps</code> and <code>cycleTime</code> are output.</li>
          </ul>
          <p>
            The core object to run everything is called the <strong>engine</strong>. The <code>Backbone.Engine</code> class is a <a href="http://backbonejs.org/#Collection" target="_blank">Backbone.Collection</a> that uses HTML5's <a href="https://developer.mozilla.org/en/docs/Web/API/window.requestAnimationFrame" target="_blank">requestAnimationFrame</a> to provide a 60 frames per second game loop. Every frame, the engine performs these things:
          </p>
          <ul>
            <li>Loop through models (in order), and calls their <code>update</code> method. Passing <code>dt</code>, the time in milliseconds since the last call to update. The update method must return <code>true</code> to ask for a redraw, or <code>false</code> not to.</li>
            <li>Loop through all models that requested a redraw, and call their <code>draw</code> method. Passing <code>context</code>, the canvas 2d context. Perform whatever magic you like in the draw method.</li>
            <li>Call itself again upon the next animation frame.</li>
          </ul>
          <div class="alert alert-info">Note: The engine does not clear the canvas before redraw. That is left up to you. See class <a href="#documentation-World">World</a> for an example.</div>
          <p>
            The <code>update</code> method is used to update the model position, animation, detect collisions, or whatever you like. If it requests a redraw, the engine will then call its <code>draw</code> method. The engine ensures that models are updated and drawn in the order they are sorted in the collection. You can define the sort order by defining a <a href="http://backbonejs.org/#Collection-comparator" target="_blank">comparator</a>.
          </p>
          <p>
            Models added to the collection receive an <code>attach</code> event and have an extra property set <code>engine</code> as backreference. When removed, they receive a <code>detach</code> event.
          </p>
          <p>
            To measure performance, two properties are set: <code>fps</code> and <code>cycleTime</code>. If you passed option <code>debugPanel</code>, they will be drawn on screen.
          </p>
          <p>
            The engine can be started and stopped. When running, will perform an update/draw sequence 60 times per second. Use methods <code>start</code>, <code>stop</code> or <code>toggle</code>. Use method <code>isRunning</code> to determine if the engine is running. If you passed option <code>input</code>, the engine will bind to the <strong>pause</strong> button to toggle start/stop.
          </p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-SpriteSheet">Backbone.SpriteSheet</h3>
          <pre>
new Backbone.SpriteSheet([attributes], [options]);
new Backbone.SpriteSheetCollection([models], [options]);
</pre>
          <p>
            <code>Backbone.SpriteSheet</code> is a Backbone model which breaks an image into frames used for animation. <code>Backbone.SpriteSheetCollection</code> is a Backbone collection of sprite sheets.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>img</code>: The element id of the image to find in the DOM. A pointer to the Image object is then stored in property <code>img</code>.</li>
            <li><code>tileWidth, tileHeight</code>: Size of tiles in pixels.</li>
            <li><code>tileColumns, tileRows</code>: Number of tiles in the image.</li>
          </ul>
          <p>
            When the sprite sheet is instantiated, an array of frames is built. A frame object contains the coordinates of the frame. It consists of <code>{x, y, width, height}</code> representing the pixel position and size of the frame. In the sprite <code>draw</code> method, these will be passed to the <a href="https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D#drawImage()" target="_blank">HTML5 canvas drawImage</a> function as arguments <code>sx, sy, sw, sh</code>.
          </p>
          <h4>Usage</h4>
          <p>
            Define your sprite sheets by creating a collection as such:
          </p>
          <pre>
this.spriteSheets = new Backbone.SpriteSheetCollection([{
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 6
}, {
  id: "tiles",
  img: "#tiles",
  tileWidth: 32,
  tileHeight: 32,
  tileColumns: 29,
  tileRows: 28
}]).attachToSpriteClasses();
</pre>
          <p>
            Here two sprite sheets are created <code>mario</code> and <code>tiles</code>. Their graphics are in <code>Image</code> objects found in the DOM. The attribute <code>img</code> is the selector to retrieve them. Note that only id selector is supported.
          </p>
          <p>
            Calling method <code>attachToSpriteClasses</code> will attach the sprite sheets to each sprite class found in the <code>Backbone</code> namespace.
          </p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-Sprite">Backbone.Sprite</h3>
          <pre>new Backbone.Sprite([attributes], [options]);</pre>
          <h4>Attributes</h4>
          <ul>
            <li><code>x, y</code>: The coordinates in pixels.</li>
            <li><code>width, height</code>: Size of the sprite in pixels.</li>
            <li><code>state</code>: The current animation.</li>
            <li><code>sequenceIndex</code>: The current animation sequence frame. Automatically set.</li>
            <li><code>spriteSheet</code>: Sprite sheet id.</li>
            <li><code>collision</code>: Optional. For use with <a href="#documentation-World">Backbone.World</a>.</li>
            <li><code>static</code>: Optional. For use with <a href="#documentation-World">Backbone.World</a>.</li>
          </ul>
          <p>
            <code>Backbone.Sprite</code> is a <a href="http://backbonejs.org/#Model" target="_blank">Backbone Model</a> which implements the required <code>update</code> and <code>draw</code> methods to animate a sprite, frame by frame.
          </p>
          <p>
            Graphics are obtained from a <a href="#documentation-SpriteSheet">Backbone.SpriteSheet</a> model. Property <code>spriteSheet</code> must point to the sprite sheet model. If you define a sprite sheet collection, you can simply set attribute <code>spriteSheet</code> to an existing sprite sheet model id. The collection will automatically attach it to the sprite. Otherwise, you will need to set property <code>spriteSheet</code> to a sprite sheet model yourself.
          </p>
          <p>
            Instantiating a sprite model is not very useful by itself. You must first extend the <code>Backbone.Sprite</code> class to provide your own animations and a pointer to the sprite sheet. For example this creates a sprite with 3 animations <code>idle</code>, <code>walk-left</code> and <code>walk-right</code>. It points to the sprite sheet id <code>mario</code>.
          </p>
          <pre>
Backbone.MySprite = Backbone.Sprite.extend({
  defaults: {
    x: 400,
    y: 400,
    spriteSheet: "mario",
    state: "idle",
    sequenceIndex: 0,
    static: false,
    collision: true
  },
  animations: {
    idle: {
      sequences: [0]
    },
    "walk-right": {
      sequences: [1, 2, 3, 2],
      delay: 200
    },
    "walk-left": {
      sequences: [1, 2, 3, 2],
      scaleX: -1,
      delay: 200
    }
  }
});
</pre>
          <h4>Animations</h4>
          <p>
            Sprite property <code>animations</code> contains a hash of animations. Each animation contains a sequence of frames and a delay between frames for animation. For example:
          </p>
          <pre>
animations: {
  idle: {
    sequences: [0, 1],
    delay: 200
  }
}
</pre>
          <p>
            This defines an animation of two frames, alternating at an interval of 200ms. Values 0 and 1 in array <code>sequences</code> are frame indices defined in the sprite sheet. Sprite attributes <code>state</code> and <code>sequenceIndex</code> control which animation and sequence are currently used. The <code>sequenceIndex</code> is automatically incremented (and reset to 0) by the sprite's draw function. Attribute <code>state</code> determines the current animation. It must be set to <code>idle</code> in the above example (as there is only one).
          </p>
          <p>
            Extra animation options are available. Here is a complete list:
          </p>
          <ul>
            <li><code>sequences</code>: Array of frame indices, or squence objects. A sequence object looks like this: <code>{frame: 52, x: 0, y: -32, scaleX: 1.00, scaleY: 1}</code>. It allows you to specify an offset to apply when the sprite is drawn, and a scaling factor.</li>
            <li><code>scaleX, scaleY</code>: Optional. Scaling factors. Set <code>scaleX</code> to -1 to flip horizontally. Defaults to 1 if omitted.</li>
            <li><code>delay</code>: Optional. The time to change to the next sequence. No need to specify if there is only one frame (as there is no animation). You can also define a sprite method <code>sequenceDelay</code> to programmatically return the delay. It will be passed the current animation.</li>
          </ul>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-Input">Backbone.Input</h3>
          <pre>new Backbone.Input([attributes], [options]);</pre>
          <p>
            <code>Backbone.Input</code> class is a model which captures user input events and stores them as model attributes. For example pressing the left arrow, sets the <code>left</code> attribute to <code>true</code>. Depressing sets it to <code>false</code>. Bind to on the attribute change event to be notified.
          </p>
          <p>
            <code>Backbone.Input</code> supports keyboard, mouse and touch events. It can draw a touchpad on screen with left and right arrow keys, an A button and a B button. Optionally, a pause button can be drawn in the middle, or the area can be used to place a banner ad.
          </p>
          <div class="alert alert-info">
            Note: The Backbone.Input model only captures input when attached to a Backbone.Engine.
          </div>
          <h4>Attributes</h4>
          <p>These attributes can be passed when creating the model, to configure the input.</p>
          <ul>
            <li><code>drawTouchpad</code>: Optional. Boolean to indicate whether to draw the touchpad. Defaults to true.</li>
            <li><code>drawPause</code>: Optional. Boolean to indicate whether to draw the pause button on the touchpad. Defaults to false.</li>
          </ul>
          <p>The following model attributes are set by the model. They should not be set externally.</p>
          <ul>
            <li><code>touchEnabled</code>: Boolean set to true if the device is touch enabled.</li>
            <li><code>left</code>: Boolean set to true when the left touchpad arrow or left keyboard arrow key is pressed.</li>
            <li><code>right</code>: Boolean set to true when the right touchpad arrow or right keyboard arrow key is pressed.</li>
            <li><code>buttonA</code>: Boolean set to true when the A touchpad button is pressed, or when the z keyboard key is pressed.</li>
            <li><code>buttonB</code>: Boolean set to true when the B touchpad button is pressed, or when the x keyboard key is pressed.</li>
            <li><code>pause</code>: Boolean set to true when the pause touchpad button is pressed, or when the p keyboard key is pressed.</li>
            <li><code>pressed</code>: Array of keys pressed on the keyboard.</li>
            <li><code>touched</code>: Array of buttons touched on touch screen.</li>
            <li><code>clicked</code>: Boolean set to true when a mouse button is pressed.</li>
          </ul>
          <h4>Helper methods</h4>
          <p>
            The following helper methods can be called ro find out what buttons are pressed.
          </p>
          <ul>
            <li><code>leftPressed</code></li>
            <li><code>rightPressed</code></li>
            <li><code>buttonAPressed</code></li>
            <li><code>buttonBPressed</code></li>
            <li><code>pausePressed</code></li>
          </ul>
          <h4>Usage</h4>
          <pre>
var input = new Backbone.Input();
var engine = new Backbone.Engine([input]);
input.bind("change:left", function(input) {
  if (input.leftPressed())
    console.log("left pressed:)");
  else
    console.log("left depressed:(");
});
</pre>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-World">Backbone.World</h3>
          <pre>new Backbone.World([attributes], [options])</pre>
          <p>
            <code>Backbone.World</code> is model which contains a collection of sprites.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>x, y</code>: Origin of top-left corner in pixels.</li>
            <li><code>width, height</code>: Size of world in tiles.</li>
            <li><code>tileWidth, tileHeight</code>: Size of a tile in pixels.</li>
            <li><code>hero</code>: Name of sprite character controlled by the user. Will be passed the input as option when instantiated.</li>
            <li><code>sprites</code>: Array of sprite models for persistence.</li>
            <li><code>backgroundColor</code>: Background color of the world.</li>
            <li><code>state</code>: Persisted state either play or edit.</li>
          </ul>
          <h4>Options</h4>
          <ul>
            <li><code>backgroundImage</code>: Optional. Pass to use a background image instead of a background color. Anchored to the origin.</li>
            <li><code>input</code>: Input instance to control the hero.</li>
            <li><code>camera</code>: Camera instance to keep the hero in the viewport.</li>
            <li><code>debugPanel</code>: Optional.</li>
          </ul>
          <p>
            Sprites can be added and removed via methods <code>add</code> and <code>remove</code>. Sprites are automatically attached to the <a heef="#documentation-Engine" target="_blank">Backbone.Engine</a> the world is attached to. In each request frame, the same mechanics apply as for sprites attached directly to an engine; methods <code>update</code> and <code>draw</code> are called for each sprite. The exception is for static sprites which are only updated/redrawn when required (see below).
          </p>
          <p>
            A world is measured in tiles via attributes <code>width</code>, <code>height</code>, <code>tileWidth</code> and <code>tileHeight</code>. Call methods <code>width</code> and <code>height</code> to get the dimensions in pixels. Attributes <code>x</code> and <code>y</code> determine the origin in pixels (top-left corner) and allow the world to be panned hence changing the viewport.
          </p>
          <p>
            Methods <code>getWorldIndex</code>, <code>getWorldCol</code> and <code>getWorldRow</code> can be used to find the position of a sprite. A sprite's <code>x</code> and <code>y</code> attributes determine their position relative to the world origin.
          </p>
          <p>
            Internally, the world keeps sprites into a collection stored in property <code>sprites</code>. It further splits sprites into 2 collections for faster lookup:
          </p>
          <ul>
            <li><code>staticSprites</code>: Background sprites that have no animation. These are usually same-sized tiles. Sprites that have their <code>static</code> attribute set to true will be put in this collection. Sprites are given an <code>id</code> determined by their position (column and row). The collection is ordered and indexed on <code>id</code> allowing for fast lookup on a point coordinates. In addition, these sprites are only drawn when required (i.e. world is panned). Use method <code>findCollidingAt</code> for quick lookup.</li>
            <li><code>dynamicSprites</code>: Animated tiles and characters. Their <code>static</code> attribute must be set to false to fall in this collection. These sprites are given unique <code>id</code> attributes based on their name (i.e. <code>mario.1</code>). They are not indexed therefore lookup of order N. Keep the number of sprites here to a minimum. Use methods <code>findAt</code> and <code>filterAt</code> to find collisions with other sprites.</li>
          </ul>
          <p>
            If you define a non-animated tile, make sure its <code>static</code> attribute is set to true. Also ensure the width of tile sprites match that of world attributes <code>tileWidth</code> and <code>tileHeight</code>. Lookup methods perform calculations assuming these things hold true.
          </p>
          <p>
            When the world is created, sprites are instantiated in method <code>spawnSprites</code>. Each sprite instance is attached to the engine. Sprites then have properties <code>engine</code> and <code>world</code> set pointing to those respective objects.
          </p>
          <h4>Persistence</h4>
          <p>
            The world model attributes contain all that is necessary to persist the state of the world to disk, or in the cloud. Calling the <code>save</code> method first serializes the sprite collection into the <code>sprites</code> attribute by calling the <code>toSave</code> method on each sprite to save their position and state. It then delegates to the backbone model's <code>save</code> method to save to a server or local storage in JSON format. See the Backbone documentation for details.
          </p>
          <p>
            The world can be restored by calling <code>restore</code> passing a saved worl in JSON format.
          </p>
          <h4>Collisions</h4>
          <p>
            Sprites inside the <code>Backbone.World</code> model can detect collisions with 3 helper methods:
          </p>
          <ul>
            <li><code>findAt(x, y, [type], [exclude], [collision])</code></li>
            <li><code>filterAt(x, y, [type], [exclude], [collision])</code></li>
            <li><code>findCollidingAt(x, y)</code></li>
          </ul>
          <p>
            The first two find the first or a list of sprites overlapping a specified point, and are meant mainly for finding moving character sprites. They have filtering options to lookup only sprites of certain types, to exclude a sprite (provided its id) and to include only sprites with attribute <code>collision</code> set to true.
          </p>
          <p>
            Method <code>findCollidingAt</code> is meant for tile lookup. It is fast since lookup is on the indexed model <code>id</code>. It returns the first sprite overlapping the passed point. It is useful for preventing characters from walking through walls or falling through tiles.
          </p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-WorldEditor">Backbone.WorldEditor</h3>
          <pre>new Backbone.WorldEditor([attributes], [options])</pre>
          <p>
            <code>Backbone.WorldEditor</code> is a model which displays a palette of sprites and allows the user to edit a <code>Backbone.World</code> instance by placing and removing sprites. Also allows the user to pan the world. An editor is usually drawn at the bottom of the world. It must be attached to a <code>Backbone.Engine</code> model.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>x, y</code>: Placement position in pixels of the editor on the canvas.</li>
            <li><code>width, height</code>: Size of editor in pixels.</li>
            <li><code>tileWidth, tileHeight</code>: Size of sprites in the palette.</li>
            <li><code>padding</code>: Padding in pixels around sprites.</li>
            <li><code>backgroundColor</code>: Background color of the editor.</li>
            <li><code>selectColor</code>: Background and outline color of a selected sprite.</li>
            <li><code>selected</code>: The name of the cuurrently selected sprite.</li>
            <li><code>spriteNames</code>: Ordered array of sprite names in the palette.</li>
          </ul>
          <h4>Options</h4>
          <ul>
            <li><code>world</code>: The Backbone.World to edit.</li>
          </ul>
          <p>
            The palette is drawn as a series of tiles left to right, top to bottom. Each tile is a sprite. The sprite may be bigger than the specified tile size, in which case it will overlap over tiles to the right or to the bottom. Therefore keep offsize sprites last, and keep an empty row below.
          </p>
          <div class="alert alert-info">
            Note: Backbone.WorldEditor depends on <a href="http://eightmedia.github.io/hammer.js/" target="_blank">hammer.js</a> for touch events (also handles mouse events). It allows panning of the world, and selection of sprites.
          </div>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-Hero">Backbone.Hero</h3>
          <pre>new Backbone.Hero([attributes], [options])</pre>
          <p>
            The <code>Backbone.Hero</code> model implements a controlable character with input and physics. Its playability is based on that of Mario in the Nintendo classic Super Mario Bros.
          </p>
          <p>
            Attach a <code>Backbone.Input</code> model to capture user input either with the keyboard (left and right arrows, z and x) or via touch events on the on-screen drawn gamepad. When added to a <code>Backbone.World</code> model, it interacts with tiles and characters.
          </p>
          <p>
            Attribute <code>state</code> determines the current animation. A state is a pair of move and direction. For example <code>idle-right</code>, <code>walk-left</code> and <code>jump-right</code>. Method <code>getStateInfo</code> will decompose the state for you into those components.
          </p>
          <p>
            With attribute <code>nextState</code>, we are able to implement tweens, or in-between animations. For example, holding the right arrow button puts the hero in a <code>walk-right</code> state (and <code>slide-right</code> next state). Releasing the right arrow button transitions to the <code>slide-right</code> state (and <code>idle-right</code> next state) for quick decelration until velocity reaches 0 to fall to the <code>idle-right</code> state. If instead the left arrow button is pressed, we transition to the <code>skid-left</code> state (and <code>walk-left</code> next state) for quicker decelartion until velocity reaches 0 to then accelerate in the opposite direction to fall in the <code>walk-left</code> state (and <code>slide-left</code> next state).
          </p>
          <p>
            Holding an arrow button and the A button (z on keyboard) allows the character to run. Its state becomes <code>run-right</code> (or <ocde>run-left</ocde>). Pressing the B button allows the character to jump (<ocde>jump-left</ocde> or <code>jump-right</code>). Hold the B button to jump higher. You can control the direction and distance jumped with the arrow buttons. And like in the real game, a jump while running will go higher to cover more distance.
          </p>
          <p>
            Physics are implemented with attributes <code>velocity</code>, <code>acceleration</code>, <code>yVelocity</code> and <code>yAcceleration</code> measured in pixels per seconds. The two first control horizontal translations over time where a positive <code>velocity</code> indicates a move to the right, and negative to the left. The latter two control vertical translations where a positive <code>yVelocity</code> indicates a move downwards, and negative upwards.
          </p>
            Each animation have targets of these properties when required. They are omitted when not (i.e. <code>walk-right</code> has not <code>yVelocity</code> or <code>yAcceleration</code>). The <code>update</code> method updates the model attributes according to the targets configured on the current animation. When <code>state</code> changes to another animation, so do the targets, and so follow the actual velocities over time to reach their targets. This gives the character momentum.
          </p>
          <p>
            Gravity is implemented with a positive <code>yAcceleration</code>. Unless atop a tile, our character will fall. However it is constrained by the extent of the canvas. And will therefore stop falling when the bottom is reaches.
          </p>
          <p>
            If our character is part of a <code>Backbone.World</code> model, it is constrained by the world extent. In addition, it can interact with other models in the world like tiles and characters. It can jump and land on tiles.
          </p>
          <p>
            In a <code>Backbone.World</code>, the character detects collisions either from tiles or other characters to constrain its movements.
          </p>
        </div>
      </div>

      <div class="row">
        <div class="col-md-12">
          <h3 id="documentation-Camera">Backbone.Camera</h3>
          <pre>new Backbone.Camera([attributes], [options])</pre>
          <p>
            Backbone.Camera is a model which ensures a sprite, the subject, is always in the viewport (the canvas). It pans the Backbone.World when the character steps out of a window in the viewport. Backbone.Camera must be added to the engine.
          </p>
          <h4>Attributes</h4>
          <ul>
            <li><code>left, right, top, bottom</code>: Coordinates of the window with respect to the drawn canvas.</li>
          </ul>
          <h4>Options</h4>
          <ul>
            <li><code>subject</code>: The sprite to keep in the viewport.</li>
            <li><code>world</code>: The Backbone.World.</li>
          </ul>
          <h4>Usage</h4>
          <pre>
var spriteSheets = new Backbone.SpriteSheetCollection({
  id: "mario",
  img: "#mario",
  tileWidth: 32,
  tileHeight: 64,
  tileColumns: 21,
  tileRows: 6
});
var mario = new Backbone.Mario();
var world = new Backbone.World();
var camera = new Backbone.Camera(
  {left: 200, right: 600, top: 0, bottom: 800},
  {subject: mario, world: world}
);
world.add(mario);
var engine = new Backbone.Engine([world, camera]);
</pre>
        </div>
      </div>

    </div>
    <br/>

    <footer class="navbar navbar-default">
        <p class="navbar-text navbar-left">
          &copy; 2014 <a href="http://martindrapeau.tumblr.com/">Martin Drapeau.</a>
          <a href="https://github.com/martindrapeau/backbone-game-engine/blob/gh-pages/LICENSE">Licensed under MIT.</a>
        </p>
        <p class="navbar-text navbar-right">Written in Montr√©al, Canada.</a></p>
        <p class="navbar-text navbar-right">&nbsp;</p>
    </footer>
    <a href="https://github.com/martindrapeau/backbone-game-engine"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"></a>
  </body>
</html>